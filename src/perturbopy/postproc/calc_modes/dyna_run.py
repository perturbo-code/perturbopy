import numpy as np
import os
from perturbopy.postproc.calc_modes.calc_mode import CalcMode
from perturbopy.postproc.dbs.recip_pt_db import RecipPtDB
from perturbopy.postproc.calc_modes.dyna_indiv_run import DynaIndivRun
from perturbopy.io_utils.io import open_yaml, open_hdf5, close_hdf5
from perturbopy.postproc.utils.timing import Timing, TimingGroup
from perturbopy.postproc.dbs.units_dict import UnitsDict


class DynaRun(CalcMode):
    """
    Class representation of a Perturbo dynamics-run calculation.

    Attributes
    ----------
    kpt : RecipPtDB
       Database for the k-points used in the bands calculation.
    bands : UnitsDict
       Database for the band energies computed by the bands calculation.
    num_runs : int
        Number of separate simulations performed
    _cdyna_file : h5py.File
        HDF5 file containing the results of the dynamics-run calculation.
        We cannot store in RAM the whole file, so we will access the data as needed.
    _tet_file : h5py.File
        HDF5 file containing the results of the setup calculation required before the dynamics-run calculation.
    _kpoints : array
        Raw array of k-points. Shape (num_kpoints, 3)
    _energies : array
        Raw array of band energies. Shape (num_kpoints, num_bands)
    _dat : dict
        Python dictionary of DynaIndivRun objects containing results from each simulation
    """

    def __init__(self, cdyna_file, tet_file, pert_dict):
        """
        Constructor method

        Parameters
        ----------
        pert_dict : dict
            Dictionary containing the inputs and outputs from the dynamics-run calculation.

        """

        self.timings = TimingGroup("dynamics-run")

        super().__init__(pert_dict)

        if self.calc_mode != 'dynamics-run':
            raise ValueError('Calculation mode for a DynamicsRunCalcMode object should be "dynamics-run"')

        self._cdyna_file = cdyna_file
        self._tet_file = tet_file

        self.pump_pulse = self._pert_dict['input parameters']['after conversion']['pump_pulse']

        if self.pump_pulse:
            if 'pump pulse' not in self._pert_dict['dynamics-run'].keys():
                raise ValueError('pump_pulse was set to .true. but no "pump pulse" key'
                                 ' was found in the dynamics-run section of the YAML file')

            pump_dict = self._pert_dict['dynamics-run']['pump pulse']
            self.pump_pulse = PumpPulse(pump_dict)

        kpoint = np.array(tet_file['kpts_all_crys_coord'][()])

        self.kpt = RecipPtDB.from_lattice(kpoint, "crystal", self.lat, self.recip_lat)

        energies = np.array(cdyna_file['band_structure_ryd'][()])
        energies_dict = {i + 1: np.array(energies[:, i]) for i in range(0, energies.shape[1])}
        self.bands = UnitsDict.from_dict(energies_dict, 'Ry')

        # k- and q-point grids
        self.boltz_kdim = np.array(self._pert_dict['input parameters']['after conversion']['boltz_kdim'])
        self.boltz_qdim = np.array(self._pert_dict['input parameters']['after conversion']['boltz_qdim'])

        # Raw arrays
        self._kpoints = kpoint
        self._energies = energies

        self._data = {}

        self.num_runs = cdyna_file['num_runs'][()]

        with self.timings.add('iterate_dyna') as t:

            for irun in range(1, self.num_runs + 1):
                dyn_str = f'dynamics_run_{irun}'

                num_steps = cdyna_file[dyn_str]['num_steps'][()]
                time_step = cdyna_file[dyn_str]['time_step_fs'][()]

                # a dynamics run must have at least one snap
                numk, numb = cdyna_file[dyn_str]['snap_t_1'][()].shape

                snap_t = np.zeros((numb, numk, num_steps), dtype=np.float64)

                for itime in range(num_steps):
                    snap_t[:, :, itime] = cdyna_file[dyn_str][f'snap_t_{itime + 1}'][()].T

                # Get E-field, which is only present if nonzero
                if "efield" in cdyna_file[dyn_str].keys():
                    efield = cdyna_file[dyn_str]["efield"][()]
                else:
                    efield = np.array([0.0, 0.0, 0.0])

                self._data[irun] = DynaIndivRun(num_steps, time_step, snap_t, time_units='fs', efield=efield)

    @classmethod
    def from_hdf5_yaml(cls, cdyna_path, tet_path, yaml_path='pert_output.yml'):
        """
        Class method to create a DynamicsRunCalcMode object from the HDF5 file and YAML file
        generated by a Perturbo calculation

        Parameters
        ----------
        cdyna_path : str
           Path to the HDF5 file generated by a dynamics-run calculation
        tet_path : str
           Path to the HDF5 file generated by the setup calculation required before the dynamics-run calculation
        yaml_path : str, optional
           Path to the YAML file generated by a dynamics-run calculation

        Returns
        -------
        dyanamics_run : DynamicsRunCalcMode
           The DynamicsRunCalcMode object generated from the HDF5 and YAML files

        """

        if not os.path.isfile(yaml_path):
            raise FileNotFoundError(f'File {yaml_path} not found')
        if not os.path.isfile(cdyna_path):
            raise FileNotFoundError(f'File {cdyna_path} not found')
        if not os.path.isfile(tet_path):
            raise FileNotFoundError(f'File {tet_path} not found')

        yaml_dict = open_yaml(yaml_path)
        cdyna_file = open_hdf5(cdyna_path)
        tet_file = open_hdf5(tet_path)

        return cls(cdyna_file, tet_file, yaml_dict)

    def close_hdf5_files(self):
        """
        Method to close the HDF5 files: _cdyna_file and _tet_file.
        After the DynaRun object is created, the HDF5 files are kept open.
        One has to close them manually.
        """

        # Check if cdyan_file is open
        if self._cdyna_file:
            print(f'Closing {self._cdyna_file.filename}')
            close_hdf5(self._cdyna_file)

        # Check if tet_file is open
        if self._tet_file:
            print(f'Closing {self._tet_file.filename}')
            close_hdf5(self._tet_file)

    def __getitem__(self, index):
        """
        Method to index the DynamicsRunCalcMode object

        Parameters
        ----------
        index : int
            The dynamics run requested, indexing starting at 1

        Returns
        -------
        dynamics_run: DynamicsRun
           Object containing information for the dynamics run

        """
        if index <= 0 or index > len(self._data):
            raise IndexError("Index out of range")

        return self._data[index]

    def __len__(self):
        """
        Method to get the number of runs in DynamicsRunCalcMode object

        Returns
        -------
        num_runs : int
            Number of runs
        """

        return self.num_runs

    def __str__(self):
        """
        Method to print the dynamics run information
        """

        title = f'dynamics-run: {self.prefix}'
        text = f"{title:*^60}\n"
        text += f"This simulation has {self.num_runs} runs\n"

        for irun, dynamics_run in self._data.items():
            text += f"{'Dynamics run':>30}: {irun}\n"
            text += f"{'Number of steps':>30}: {dynamics_run.num_steps}\n"
            text += f"{'Time step (fs)':>30}: {dynamics_run.time_step}\n"
            text += f"{'Electric field (V/cm)':>30}: {dynamics_run.efield}\n\n"

        return text

    def extract_steady_drift_vel(self, dyna_pp_yaml_path):
        """
        Method to extract the drift velocities and equilibrium carrier concentrations

        Returns
        -------
        num_runs : int
            Number of runs
        """

        if not os.path.isfile(dyna_pp_yaml_path):
            raise FileNotFoundError(f'File {dyna_pp_yaml_path} not found')

        dyna_pp_dict = open_yaml(dyna_pp_yaml_path)

        vels = dyna_pp_dict['dynamics-pp']['velocity']
        concs = dyna_pp_dict['dynamics-pp']['concentration']

        step_number = 0

        steady_drift_vel = []
        steady_conc = []

        for irun, dynamics_run in self._data.items():

            step_number += dynamics_run.num_steps

            if np.allclose(dynamics_run.efield, np.array([0.0, 0.0, 0.0])):
                steady_drift_vel.append(None)
                steady_conc.append(concs[step_number])
            else:
                steady_drift_vel.append((-1.0) * vels[step_number])
                steady_conc.append(concs[step_number])

        return steady_drift_vel, steady_conc


class PumpPulse():
    """
    Class for pump pulse excitation.

    Attributes
    ----------

    pump_energy : float
        Energy of the pump pulse excitation in eV.

    energy_broadening : float
        Energy broadening of the pump pulse excitation in eV.

    num_steps : int
        Number of steps in the pump pulse excitation.

    time_step : float
        Time step of the pump pulse excitation in fs.

    num_kpoints : int
        Number of k-points in the pump pulse excitation. Tailored for the Perturbo dynamics-run calculation.

    carrier_number_array : np.ndarray
        Additional carrier number array for the pump pulse excitation.

    optional_params : dict
        Optional parameters for the pump pulse excitation.
        Specific to the pulse shape. 10 parameters allocated.

    hole : bool
        Flag to indicate if the pump pulse excitation is for the hole.
        Must be the same as in the ultrafast simulation.
    """

    def __init__(self, pump_dict):
        """
        Constructor method

        Parameters
        ----------
        pump_dict : dict
            Dictionary containing the pump pulse excitation parameters.
        """

        # TODO: use UnitsDict for entries in pump_dict
        # CURRENTLY, UnitsDict seems to be ill-suited for floats with units
        # input_dict = {'pump_energy': pump_dict['pump_energy']}
        # self.pump_energy = UnitsDict.from_dict(input_dict, units='eV')

        self.pump_energy = pump_dict['pump_energy']
        self.pump_energy_units = pump_dict['pump_energy units']

        self.energy_broadening = pump_dict['energy_broadening']
        self.energy_broadening_units = pump_dict['energy_broadening units']

        self.num_steps = pump_dict['num_steps']

        self.time_step = pump_dict['time_step']
        self.time_step_units = pump_dict['time_step units']

        self.num_kpoints = pump_dict['num_kpoints']

        self.carrier_number_array = \
            np.array(pump_dict['pump pulse carrier number'])
        self.carrier_number_units = pump_dict['carrier_number units']

        # Optional parameters are specific to the pump pulse excitation
        # 10 parameters allocated
        self.optional_params = pump_dict['optional_params']

        self.hole = pump_dict['hole']

    def __str__(self):
        """
        Method to print the pump pulse excitation parameters.
        """

        text = 'Pump pulse excitation parameters:\n'
        text += f"{'Pump energy':>30}: {self.pump_energy} {self.pump_energy_units}\n"
        text += f"{'Energy broadening':>30}: {self.energy_broadening} {self.energy_broadening_units}\n"
        text += f"{'Number of steps':>30}: {self.num_steps}\n"
        text += f"{'Time step':>30}: {self.time_step} {self.time_step_units}\n"
        text += f"{'Hole':>30}: {self.hole}\n"

        return text
